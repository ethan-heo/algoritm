# 백준 9663번 - N-Queen 문제 풀이

> Claude가 작성한 문제 풀이 내용

## 문제 설명

N×N 크기의 체스판에 N개의 퀸을 배치하는 문제입니다.

- 퀸들은 서로 공격할 수 없어야 합니다.
- 퀸은 상하좌우 + 대각선 8방향으로 이동 가능합니다.
- 같은 행, 같은 열, 같은 대각선에 다른 퀸이 있으면 안 됩니다.

---

## 🎯 Step 1: 퀸이 공격하는 방향 이해하기

4×4 체스판에 (1,1) 위치에 퀸을 놓으면:

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │ X │ X │   │   │  ← 같은 대각선
  ├───┼───┼───┼───┤
1 │ X │ Q │ X │ X │  ← 같은 행 (모두 X)
  ├───┼───┼───┼───┤
2 │ X │ X │ X │   │  ← 같은 대각선
  ├───┼───┼───┼───┤
3 │   │ X │   │ X │
  └───┴───┴───┴───┘
    ↑   ↑       ↑
  같은  같은   같은
  대각선 열   대각선
```

**X 표시된 곳**: 다른 퀸을 놓을 수 없는 위치

---

## 🤔 Step 2: 왜 배열이 필요한가?

**문제**: 새로운 위치 (2,3)에 퀸을 놓을 수 있는지 확인하려면?

### 나쁜 방법 ❌

이미 놓인 모든 퀸의 위치를 확인

- 퀸1과 같은 행/열/대각선인가?
- 퀸2와 같은 행/열/대각선인가?
- ...계속 반복

### 좋은 방법 ✅

배열로 빠르게 확인

- 3번 열이 비어있나? → `cols[3]` 확인
- 대각선이 비어있나? → `diag1[?]` 확인
- 역대각선이 비어있나? → `diag2[?]` 확인

---

## 📝 Step 3: 열(Column) 배열

```javascript
cols = [false, false, false, false];
//      col0   col1   col2   col3
```

### 실습: 퀸을 하나씩 놓아보기

#### 초기 상태

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │   │   │   │   │
1 │   │   │   │   │
2 │   │   │   │   │
3 │   │   │   │   │
  └───┴───┴───┴───┘

cols = [false, false, false, false]
```

#### Step A: (0,1)에 퀸을 놓음

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │   │ Q │   │   │  ← 1번 열에 퀸
1 │   │   │   │   │
2 │   │   │   │   │
3 │   │   │   │   │
  └───┴───┴───┴───┘

cols = [false, TRUE, false, false]
              ↑
         1번 열 사용중!
```

**의미**: "1번 열에는 이미 퀸이 있어요"

#### Step B: (2,3)에 퀸을 또 놓음

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │   │ Q │   │   │
1 │   │   │   │   │
2 │   │   │   │ Q │  ← 3번 열에 퀸
3 │   │   │   │   │
  └───┴───┴───┴───┘

cols = [false, TRUE, false, TRUE]
              ↑              ↑
         1번 열 사용   3번 열 사용
```

#### Step C: (3,2)에 퀸을 놓을 수 있나요?

```
cols[2]를 확인 → false (비어있음) → 놓을 수 있어요!
```

#### Step D: (3,1)에 퀸을 놓을 수 있나요?

```
cols[1]를 확인 → TRUE (이미 사용중) → 못 놓아요!
```

### 정리

- `cols` 배열은 각 열에 퀸이 있는지 체크
- `cols[열번호]`가 `true`면 그 열에는 퀸을 놓을 수 없음

---

## 📐 Step 4: 대각선(↘) 배열

먼저 대각선들을 번호로 표시해봅시다:

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │ 3 │ 2 │ 1 │ 0 │
  ├───┼───┼───┼───┤
1 │ 4 │ 3 │ 2 │ 1 │
  ├───┼───┼───┼───┤
2 │ 5 │ 4 │ 3 │ 2 │
  ├───┼───┼───┼───┤
3 │ 6 │ 5 │ 4 │ 3 │
  └───┴───┴───┴───┘
```

**같은 번호 = 같은 대각선(↘)**

예를 들어:

- 번호 3인 칸들: (0,0), (1,1), (2,2), (3,3) ← 같은 대각선!
- 번호 2인 칸들: (0,1), (1,2), (2,3) ← 같은 대각선!

### 🧮 번호 계산 공식

위치 (row, col)의 대각선 번호 = `row - col + 3`

**예시**:

- (0,0): 0 - 0 + 3 = **3**
- (1,1): 1 - 1 + 3 = **3** ← 같은 번호!
- (0,1): 0 - 1 + 3 = **2**
- (1,2): 1 - 2 + 3 = **2** ← 같은 번호!

### 실습: 대각선 배열 사용하기

```javascript
diag1 = [false, false, false, false, false, false, false];
//       번호0   번호1   번호2   번호3   번호4   번호5   번호6
```

#### 초기 상태

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │   │   │   │   │
1 │   │   │   │   │
2 │   │   │   │   │
3 │   │   │   │   │
  └───┴───┴───┴───┘

diag1 = [false, false, false, false, false, false, false]
```

#### Step A: (1,1)에 퀸을 놓음

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │   │   │   │   │
1 │   │ Q │   │   │  ← (1,1)의 대각선 번호 = 1-1+3 = 3
2 │   │   │   │   │
3 │   │   │   │   │
  └───┴───┴───┴───┘

diag1 = [false, false, false, TRUE, false, false, false]
                             ↑
                        3번 대각선 사용중!
```

#### Step B: (2,2)에 퀸을 놓을 수 있나요?

1. (2,2)의 대각선 번호 계산: 2 - 2 + 3 = **3**
2. `diag1[3]` 확인 → `TRUE` (이미 사용중)
3. **못 놓아요!** ❌

왜? (1,1)과 (2,2)는 같은 대각선이니까!

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │ X │   │   │   │
1 │   │ Q │   │   │  ← 같은 대각선(번호3)
2 │   │   │ X │   │  ← 여기 못 놓음!
3 │   │   │   │ X │
  └───┴───┴───┴───┘
```

#### Step C: (0,1)에는 퀸을 놓을 수 있나요?

1. (0,1)의 대각선 번호: 0 - 1 + 3 = **2**
2. `diag1[2]` 확인 → `false` (비어있음)
3. **놓을 수 있어요!** ✅

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │   │ Q'│   │   │  ← 다른 대각선(번호2)
1 │   │ Q │   │   │  ← 대각선(번호3)
2 │   │   │   │   │
3 │   │   │   │   │
  └───┴───┴───┴───┘

diag1 = [false, false, TRUE, TRUE, false, false, false]
                      ↑     ↑
                   번호2  번호3 사용중
```

### 정리

- 각 대각선에 번호를 매김 (0~6번)
- 번호 계산: `row - col + (N-1)`
- `diag1[번호]`가 `true`면 그 대각선에 퀸 있음

---

## 📐 Step 5: 역대각선(↙) 배열

이번에는 반대 방향 대각선에 번호를 매깁니다:

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │ 0 │ 1 │ 2 │ 3 │
  ├───┼───┼───┼───┤
1 │ 1 │ 2 │ 3 │ 4 │
  ├───┼───┼───┼───┤
2 │ 2 │ 3 │ 4 │ 5 │
  ├───┼───┼───┼───┤
3 │ 3 │ 4 │ 5 │ 6 │
  └───┴───┴───┴───┘
```

**같은 번호 = 같은 역대각선(↙)**

예를 들어:

- 번호 3인 칸들: (0,3), (1,2), (2,1), (3,0) ← 같은 역대각선!
- 번호 4인 칸들: (1,3), (2,2), (3,1) ← 같은 역대각선!

### 🧮 번호 계산 공식

위치 (row, col)의 역대각선 번호 = `row + col`

**예시**:

- (0,3): 0 + 3 = **3**
- (1,2): 1 + 2 = **3** ← 같은 번호!
- (2,2): 2 + 2 = **4**
- (3,1): 3 + 1 = **4** ← 같은 번호!

### 실습: 역대각선 배열 사용하기

```javascript
diag2 = [false, false, false, false, false, false, false];
//       번호0   번호1   번호2   번호3   번호4   번호5   번호6
```

#### 초기 상태

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │   │   │   │   │
1 │   │   │   │   │
2 │   │   │   │   │
3 │   │   │   │   │
  └───┴───┴───┴───┘

diag2 = [false, false, false, false, false, false, false]
```

#### Step A: (1,2)에 퀸을 놓음

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │   │   │   │   │
1 │   │   │ Q │   │  ← (1,2)의 역대각선 번호 = 1+2 = 3
2 │   │   │   │   │
3 │   │   │   │   │
  └───┴───┴───┴───┘

diag2 = [false, false, false, TRUE, false, false, false]
                             ↑
                        3번 역대각선 사용중!
```

#### Step B: (2,1)에 퀸을 놓을 수 있나요?

1. (2,1)의 역대각선 번호 계산: 2 + 1 = **3**
2. `diag2[3]` 확인 → `TRUE` (이미 사용중)
3. **못 놓아요!** ❌

왜? (1,2)와 (2,1)은 같은 역대각선이니까!

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │   │   │   │ X │
1 │   │   │ Q │   │  ← 같은 역대각선(번호3)
2 │   │ X │   │   │  ← 여기 못 놓음!
3 │ X │   │   │   │
  └───┴───┴───┴───┘
```

#### Step C: (2,2)에는 퀸을 놓을 수 있나요?

1. (2,2)의 역대각선 번호: 2 + 2 = **4**
2. `diag2[4]` 확인 → `false` (비어있음)
3. **놓을 수 있어요!** ✅

```
     0   1   2   3
  ┌───┬───┬───┬───┐
0 │   │   │   │   │
1 │   │   │ Q │   │  ← 역대각선(번호3)
2 │   │   │ Q'│   │  ← 다른 역대각선(번호4)
3 │   │   │   │   │
  └───┴───┴───┴───┘

diag2 = [false, false, false, TRUE, TRUE, false, false]
                             ↑     ↑
                          번호3  번호4 사용중
```

### 정리

- 각 역대각선에 번호를 매김 (0~6번)
- 번호 계산: `row + col`
- `diag2[번호]`가 `true`면 그 역대각선에 퀸 있음

---

## 🎯 Step 6: 전체 종합

한 위치에 퀸을 놓을 수 있는지 **3가지를 모두 체크**합니다:

### 예: (2,3)에 퀸을 놓을 수 있나요?

```
1. 열 체크: cols[3] → 비어있나?
2. 대각선 체크: diag1[2-3+3=2] → 비어있나?
3. 역대각선 체크: diag2[2+3=5] → 비어있나?

→ 3개 모두 false면 놓을 수 있어요! ✅
→ 하나라도 true면 못 놓아요! ❌
```

---

## 💡 최종 코드 구조

```javascript
function solution(input) {
	const N = parseInt(input);

	// 체크 배열들
	const cols = new Array(N).fill(false); // 열 체크
	const diag1 = new Array(2 * N - 1).fill(false); // 대각선(↘) 체크
	const diag2 = new Array(2 * N - 1).fill(false); // 역대각선(↙) 체크

	let count = 0;

	function backtrack(row) {
		// 모든 행에 퀸을 다 놓았다 → 성공!
		if (row === N) {
			count++;
			return;
		}

		// 현재 row의 각 열(col)을 시도
		for (let col = 0; col < N; col++) {
			const d1 = row - col + (N - 1); // 대각선 번호
			const d2 = row + col; // 역대각선 번호

			// 1. 체크: 놓을 수 있나?
			if (cols[col] || diag1[d1] || diag2[d2]) {
				continue;
			}

			// 2. 퀸 배치
			cols[col] = true;
			diag1[d1] = true;
			diag2[d2] = true;

			// 3. 다음 행으로
			backtrack(row + 1);

			// 4. 백트래킹 (복원)
			cols[col] = false;
			diag1[d1] = false;
			diag2[d2] = false;
		}
	}

	backtrack(0);
	return count;
}
```

---

## 🔍 백트래킹 동작 원리

1. **0번 행부터 시작**해서 각 행에 퀸을 하나씩 배치
2. 현재 행의 **모든 열을 순서대로 시도**
3. 퀸을 놓을 수 있으면 → 배치하고 **다음 행으로 재귀 호출**
4. 막다른 길에 도달하면 → **되돌아가서(백트래킹)** 다른 위치 시도
5. N개의 퀸을 모두 배치하면 → **경우의 수 +1**

---

## ⏱️ 시간복잡도

- 최악: O(N!) - 모든 경우를 탐색
- 실제로는 가지치기(pruning)로 훨씬 빠름
  - 불가능한 경로는 조기에 차단
  - 배열로 O(1) 시간에 체크 가능

---

## 📊 예시 결과

- N=4: 2가지
- N=8: 92가지
- N=12: 14,200가지
