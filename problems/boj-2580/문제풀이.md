# 백준 2580번 - 스도쿠

## 문제 정보

- **문제 번호**: 2580
- **문제 이름**: 스도쿠
- **링크**: https://www.acmicpc.net/problem/2580
- **난이도**: Gold 4
- **알고리즘**: 백트래킹(Backtracking), DFS

## 문제 설명

9×9 스도쿠 판이 주어지고, 빈 칸(0으로 표시)을 채워서 완성된 스도쿠를 출력하는 문제입니다.

**스도쿠 규칙:**

- 각 **행**에는 1~9가 중복 없이 들어가야 함
- 각 **열**에는 1~9가 중복 없이 들어가야 함
- 각 **3×3 박스**에는 1~9가 중복 없이 들어가야 함

## 접근 방법

### 1️⃣ 문제 분류

"모든 가능성을 탐색하되, 조건 위반 시 되돌아가야 한다" → **백트래킹(Backtracking)** 문제

### 2️⃣ 핵심 아이디어

1. 빈 칸에 1~9를 **순차적으로 시도**
2. 각 숫자가 **스도쿠 규칙을 만족**하는지 검증
3. 만족하면 다음 빈 칸으로 진행, 실패하면 **이전 선택을 취소(backtrack)**

### 3️⃣ 메타 사고 과정

**왜 백트래킹인가?**

- 완전 탐색이 필요하지만, 모든 경우를 다 보면 9^81 (불가능)
- 조건을 만족하지 않는 경로는 **가지치기(pruning)** 가능
- DFS + 되돌리기 패턴 = 백트래킹

**최적화 전략**

1. 빈 칸을 미리 찾아서 저장 (재귀마다 0 찾지 않기)
2. 유효성 검사를 통한 조기 가지치기
3. 해를 찾으면 즉시 종료

## 알고리즘 & 자료구조

### 사용한 자료구조

- **2차원 배열**: 9×9 스도쿠 판
- **1차원 배열**: 빈 칸의 좌표 `[row, col]` 목록

### 알고리즘 단계

```
1. 빈 칸(0인 위치) 찾기 → emptyCells 배열에 저장
2. 백트래킹 시작 (index=0)
   │
   ├─ 기저 조건: index === emptyCells.length → 성공
   │
   ├─ 현재 빈 칸에 1~9 시도
   │   │
   │   ├─ 유효성 검사 (행/열/박스)
   │   │
   │   ├─ ✓ 유효 → 숫자 배치 → 다음 칸 재귀
   │   │                      │
   │   │                      ├─ ✓ 성공 → return true
   │   │                      └─ ✗ 실패 → 숫자 제거 (백트래킹)
   │   │
   │   └─ ✗ 유효하지 않음 → 다음 숫자 시도
   │
   └─ 1~9 모두 실패 → return false
```

## 구현 상세

### 1. 빈 칸 찾기

```javascript
function findEmptyCells(board) {
	const emptyCells = [];
	for (let i = 0; i < 9; i++) {
		for (let j = 0; j < 9; j++) {
			if (board[i][j] === 0) {
				emptyCells.push([i, j]);
			}
		}
	}
	return emptyCells;
}
```

### 2. 유효성 검사

```javascript
function isValid(board, row, col, num) {
	// 행 검사
	for (let j = 0; j < 9; j++) {
		if (board[row][j] === num) return false;
	}

	// 열 검사
	for (let i = 0; i < 9; i++) {
		if (board[i][col] === num) return false;
	}

	// 3×3 박스 검사
	const boxRow = Math.floor(row / 3) * 3;
	const boxCol = Math.floor(col / 3) * 3;

	for (let i = boxRow; i < boxRow + 3; i++) {
		for (let j = boxCol; j < boxCol + 3; j++) {
			if (board[i][j] === num) return false;
		}
	}

	return true;
}
```

**3×3 박스 시작점 계산:**

- `Math.floor(row / 3) * 3`
- 예: row=4 → Math.floor(4/3)\*3 = 3 (중앙 박스 시작)
- 예: row=7 → Math.floor(7/3)\*3 = 6 (하단 박스 시작)

### 3. 백트래킹 핵심

```javascript
function solve(board, emptyCells, index) {
	if (index === emptyCells.length) {
		return true; // 모든 빈 칸을 채움
	}

	const [row, col] = emptyCells[index];

	for (let num = 1; num <= 9; num++) {
		if (isValid(board, row, col, num)) {
			board[row][col] = num; // Choose

			if (solve(board, emptyCells, index + 1)) {
				return true; // Explore 성공
			}

			board[row][col] = 0; // Unchoose (백트래킹)
		}
	}

	return false;
}
```

**백트래킹 3단계:**

1. **Choose**: 선택 (`board[row][col] = num`)
2. **Explore**: 탐색 (다음 빈 칸으로 재귀)
3. **Unchoose**: 취소 (`board[row][col] = 0`)

## 복잡도 분석

### 시간 복잡도

- **최악**: O(9^(빈칸개수))
  - 각 빈 칸에 9가지 선택지
  - 빈 칸이 많을수록 기하급수적 증가
- **실제**: 가지치기로 대폭 감소
  - 유효성 검사로 불가능한 경로 제거
  - 평균적으로 훨씬 빠르게 동작

### 공간 복잡도

- **O(빈칸개수)**: 재귀 호출 스택 + emptyCells 배열

## 핵심 포인트

### ✅ 주의사항

1. **배열 참조 전달**: board를 직접 수정하므로 백트래킹 시 반드시 원상복구
2. **조기 종료**: 해를 찾으면 즉시 `return true`로 종료
3. **출력 형식**: 각 행을 공백으로 구분, 줄바꿈으로 구분

### 💡 최적화 아이디어

1. **빈 칸 미리 저장**: 재귀마다 0 찾지 않고 O(1) 접근
2. **비트마스크**: 행/열/박스별 사용된 숫자를 비트로 관리 (더 빠른 검증)
3. **최소 선택지 우선**: 선택지가 적은 빈 칸부터 채우기 (가지치기 효과 극대화)
